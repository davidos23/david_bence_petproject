ANN_F1 <- rbind(ANN_F1,cfm_looped$byClass[7])
print(num2str(i*100/K)," %")
}
selected_cut_off=0.5 #Ez lesz a választott cut-offunk, de tapasztalatok szerint a becsült bináris adat nagyon ritkán esik túl távol 0-tól vagy 1-től, így a 0.1 vagy 0.9-es cut-off ugyanazt az eredményt nyújtja
ANN_Accuracy = array()
ANN_Precision = array()
ANN_Recall = array()
ANN_F1 = array()
K=100
for (i in 1:K){
#Splittelés
train_index_loop <- createDataPartition(heart_kesz$HeartDisease,p=0.7,list = FALSE)
heart_kesz_train_loop <- heart_kesz[train_index_loop,]
heart_kesz_test_loop <- heart_kesz[-train_index_loop,]
#Neurális háló tanítása
ANN_looped <- neuralnet(as.factor(HeartDisease)~., data = heart_kesz_train_loop,hidden=c(5,3),linear.output = FALSE,stepmax=1e4)
#Becslés
pred_loop <- predict(ANN_looped,heart_kesz_test_loop)[,2] %>% round(3)
pred_loop <- sapply(pred_loop,classifier,cut_off=selected_cut_off)
#Eredmények feljegyzése
cfm_looped <- confusionMatrix(data = factor(pred_loop), reference = factor(heart_kesz_test_loop$HeartDisease), mode = "prec_recall")
ANN_Accuracy <- rbind(ANN_Accuracy,cfm_looped$overall[1])
ANN_Precision <- rbind(ANN_Precision,cfm_looped$byClass[5])
ANN_Recall <- rbind(ANN_Recall,cfm_looped$byClass[6])
ANN_F1 <- rbind(ANN_F1,cfm_looped$byClass[7])
print(str(i*100/K)," %")
}
str(i*100/K)
print(str(i*100/K)," %")
print(str(2)," %")
print(cbind(str(2)," %"))
print(2, " %")
print(2, " %")
print(2," %")
print(c(2,"%"))
print(c(2+4,"%"))
selected_cut_off=0.5 #Ez lesz a választott cut-offunk, de tapasztalatok szerint a becsült bináris adat nagyon ritkán esik túl távol 0-tól vagy 1-től, így a 0.1 vagy 0.9-es cut-off ugyanazt az eredményt nyújtja
ANN_Accuracy = array()
ANN_Precision = array()
ANN_Recall = array()
ANN_F1 = array()
K=100
for (i in 1:K){
#Splittelés
train_index_loop <- createDataPartition(heart_kesz$HeartDisease,p=0.7,list = FALSE)
heart_kesz_train_loop <- heart_kesz[train_index_loop,]
heart_kesz_test_loop <- heart_kesz[-train_index_loop,]
#Neurális háló tanítása
ANN_looped <- neuralnet(as.factor(HeartDisease)~., data = heart_kesz_train_loop,hidden=c(5,3),linear.output = FALSE,stepmax=1e4)
#Becslés
pred_loop <- predict(ANN_looped,heart_kesz_test_loop)[,2] %>% round(3)
pred_loop <- sapply(pred_loop,classifier,cut_off=selected_cut_off)
#Eredmények feljegyzése
cfm_looped <- confusionMatrix(data = factor(pred_loop), reference = factor(heart_kesz_test_loop$HeartDisease), mode = "prec_recall")
ANN_Accuracy <- rbind(ANN_Accuracy,cfm_looped$overall[1])
ANN_Precision <- rbind(ANN_Precision,cfm_looped$byClass[5])
ANN_Recall <- rbind(ANN_Recall,cfm_looped$byClass[6])
ANN_F1 <- rbind(ANN_F1,cfm_looped$byClass[7])
print(i*100/K)
}
selected_cut_off=0.5 #Ez lesz a választott cut-offunk, de tapasztalatok szerint a becsült bináris adat nagyon ritkán esik túl távol 0-tól vagy 1-től, így a 0.1 vagy 0.9-es cut-off ugyanazt az eredményt nyújtja
ANN_Accuracy = array()
ANN_Precision = array()
ANN_Recall = array()
ANN_F1 = array()
K=100
for (i in 1:K){
#Splittelés
train_index_loop <- createDataPartition(heart_kesz$HeartDisease,p=0.7,list = FALSE)
heart_kesz_train_loop <- heart_kesz[train_index_loop,]
heart_kesz_test_loop <- heart_kesz[-train_index_loop,]
#Neurális háló tanítása
ANN_looped <- neuralnet(as.factor(HeartDisease)~., data = heart_kesz_train_loop,hidden=c(5,3),linear.output = FALSE,stepmax=1e5)
#Becslés
pred_loop <- predict(ANN_looped,heart_kesz_test_loop)[,2] %>% round(3)
pred_loop <- sapply(pred_loop,classifier,cut_off=selected_cut_off)
#Eredmények feljegyzése
cfm_looped <- confusionMatrix(data = factor(pred_loop), reference = factor(heart_kesz_test_loop$HeartDisease), mode = "prec_recall")
ANN_Accuracy <- rbind(ANN_Accuracy,cfm_looped$overall[1])
ANN_Precision <- rbind(ANN_Precision,cfm_looped$byClass[5])
ANN_Recall <- rbind(ANN_Recall,cfm_looped$byClass[6])
ANN_F1 <- rbind(ANN_F1,cfm_looped$byClass[7])
print(i*100/K)
}
selected_cut_off=0.5 #Ez lesz a választott cut-offunk, de tapasztalatok szerint a becsült bináris adat nagyon ritkán esik túl távol 0-tól vagy 1-től, így a 0.1 vagy 0.9-es cut-off ugyanazt az eredményt nyújtja
ANN_Accuracy = array()
ANN_Precision = array()
ANN_Recall = array()
ANN_F1 = array()
K=100
for (i in 1:K){
#Splittelés
train_index_loop <- createDataPartition(heart_kesz$HeartDisease,p=0.7,list = FALSE)
heart_kesz_train_loop <- heart_kesz[train_index_loop,]
heart_kesz_test_loop <- heart_kesz[-train_index_loop,]
#Neurális háló tanítása
ANN_looped <- try(neuralnet(as.factor(HeartDisease)~., data = heart_kesz_train_loop,hidden=c(5,3),linear.output = FALSE,stepmax=1e4))
if(inherits(ANN_looped,"try-error")){next}
#Becslés
pred_loop <- predict(ANN_looped,heart_kesz_test_loop)[,2] %>% round(3)
pred_loop <- sapply(pred_loop,classifier,cut_off=selected_cut_off)
#Eredmények feljegyzése
cfm_looped <- confusionMatrix(data = factor(pred_loop), reference = factor(heart_kesz_test_loop$HeartDisease), mode = "prec_recall")
ANN_Accuracy <- rbind(ANN_Accuracy,cfm_looped$overall[1])
ANN_Precision <- rbind(ANN_Precision,cfm_looped$byClass[5])
ANN_Recall <- rbind(ANN_Recall,cfm_looped$byClass[6])
ANN_F1 <- rbind(ANN_F1,cfm_looped$byClass[7])
print(i*100/K)
}
selected_cut_off=0.5 #Ez lesz a választott cut-offunk, de tapasztalatok szerint a becsült bináris adat nagyon ritkán esik túl távol 0-tól vagy 1-től, így a 0.1 vagy 0.9-es cut-off ugyanazt az eredményt nyújtja
ANN_Accuracy = array()
ANN_Precision = array()
ANN_Recall = array()
ANN_F1 = array()
K=100
for (i in 1:K){
#Splittelés
train_index_loop <- createDataPartition(heart_kesz$HeartDisease,p=0.7,list = FALSE)
heart_kesz_train_loop <- heart_kesz[train_index_loop,]
heart_kesz_test_loop <- heart_kesz[-train_index_loop,]
#Neurális háló tanítása
ANN_looped <- try(neuralnet(as.factor(HeartDisease)~., data = heart_kesz_train_loop,hidden=c(5,3),linear.output = FALSE,stepmax=1e4))
if(inherits(ANN_looped,"try-error")){next i}
selected_cut_off=0.5 #Ez lesz a választott cut-offunk, de tapasztalatok szerint a becsült bináris adat nagyon ritkán esik túl távol 0-tól vagy 1-től, így a 0.1 vagy 0.9-es cut-off ugyanazt az eredményt nyújtja
ANN_Accuracy = array()
ANN_Precision = array()
ANN_Recall = array()
ANN_F1 = array()
K=100
for (i in 1:K){
#Splittelés
train_index_loop <- createDataPartition(heart_kesz$HeartDisease,p=0.7,list = FALSE)
heart_kesz_train_loop <- heart_kesz[train_index_loop,]
heart_kesz_test_loop <- heart_kesz[-train_index_loop,]
#Neurális háló tanítása
tryCatch({
ANN_looped <- neuralnet(as.factor(HeartDisease)~., data = heart_kesz_train_loop,hidden=c(5,3),linear.output = FALSE,stepmax=1e4)
},
error=funnction(e){next})
selected_cut_off=0.5 #Ez lesz a választott cut-offunk, de tapasztalatok szerint a becsült bináris adat nagyon ritkán esik túl távol 0-tól vagy 1-től, így a 0.1 vagy 0.9-es cut-off ugyanazt az eredményt nyújtja
ANN_Accuracy = array()
ANN_Precision = array()
ANN_Recall = array()
ANN_F1 = array()
K=100
for (i in 1:K){
#Splittelés
train_index_loop <- createDataPartition(heart_kesz$HeartDisease,p=0.7,list = FALSE)
heart_kesz_train_loop <- heart_kesz[train_index_loop,]
heart_kesz_test_loop <- heart_kesz[-train_index_loop,]
#Neurális háló tanítása
tryCatch({
ANN_looped <- neuralnet(as.factor(HeartDisease)~., data = heart_kesz_train_loop,hidden=c(5,3),linear.output = FALSE,stepmax=1e4)
},
error=funnction(e) {})
selected_cut_off=0.5 #Ez lesz a választott cut-offunk, de tapasztalatok szerint a becsült bináris adat nagyon ritkán esik túl távol 0-tól vagy 1-től, így a 0.1 vagy 0.9-es cut-off ugyanazt az eredményt nyújtja
ANN_Accuracy = array()
ANN_Precision = array()
ANN_Recall = array()
ANN_F1 = array()
K=100
for (i in 1:K){
#Splittelés
train_index_loop <- createDataPartition(heart_kesz$HeartDisease,p=0.7,list = FALSE)
heart_kesz_train_loop <- heart_kesz[train_index_loop,]
heart_kesz_test_loop <- heart_kesz[-train_index_loop,]
#Neurális háló tanítása
tryCatch({
ANN_looped <- neuralnet(as.factor(HeartDisease)~., data = heart_kesz_train_loop,hidden=c(5,3),linear.output = FALSE,stepmax=1e4)
},
error=function(e){next})
#Becslés
pred_loop <- predict(ANN_looped,heart_kesz_test_loop)[,2] %>% round(3)
pred_loop <- sapply(pred_loop,classifier,cut_off=selected_cut_off)
#Eredmények feljegyzése
cfm_looped <- confusionMatrix(data = factor(pred_loop), reference = factor(heart_kesz_test_loop$HeartDisease), mode = "prec_recall")
ANN_Accuracy <- rbind(ANN_Accuracy,cfm_looped$overall[1])
ANN_Precision <- rbind(ANN_Precision,cfm_looped$byClass[5])
ANN_Recall <- rbind(ANN_Recall,cfm_looped$byClass[6])
ANN_F1 <- rbind(ANN_F1,cfm_looped$byClass[7])
print(i*100/K)
}
selected_cut_off=0.5 #Ez lesz a választott cut-offunk, de tapasztalatok szerint a becsült bináris adat nagyon ritkán esik túl távol 0-tól vagy 1-től, így a 0.1 vagy 0.9-es cut-off ugyanazt az eredményt nyújtja
ANN_Accuracy = array()
ANN_Precision = array()
ANN_Recall = array()
ANN_F1 = array()
K=100
for (i in 1:K){
#Splittelés
train_index_loop <- createDataPartition(heart_kesz$HeartDisease,p=0.7,list = FALSE)
heart_kesz_train_loop <- heart_kesz[train_index_loop,]
heart_kesz_test_loop <- heart_kesz[-train_index_loop,]
#Neurális háló tanítása
tryCatch({
ANN_looped <- neuralnet(as.factor(HeartDisease)~., data = heart_kesz_train_loop,hidden=c(5,3),linear.output = FALSE,stepmax=1e4)
#Becslés
pred_loop <- predict(ANN_looped,heart_kesz_test_loop)[,2] %>% round(3)
pred_loop <- sapply(pred_loop,classifier,cut_off=selected_cut_off)
#Eredmények feljegyzése
cfm_looped <- confusionMatrix(data = factor(pred_loop), reference = factor(heart_kesz_test_loop$HeartDisease), mode = "prec_recall")
ANN_Accuracy <- rbind(ANN_Accuracy,cfm_looped$overall[1])
ANN_Precision <- rbind(ANN_Precision,cfm_looped$byClass[5])
ANN_Recall <- rbind(ANN_Recall,cfm_looped$byClass[6])
ANN_F1 <- rbind(ANN_F1,cfm_looped$byClass[7])
},
error=function(e){next})
print(i*100/K)
}
selected_cut_off=0.5 #Ez lesz a választott cut-offunk, de tapasztalatok szerint a becsült bináris adat nagyon ritkán esik túl távol 0-tól vagy 1-től, így a 0.1 vagy 0.9-es cut-off ugyanazt az eredményt nyújtja
ANN_Accuracy = array()
ANN_Precision = array()
ANN_Recall = array()
ANN_F1 = array()
K=100
for (i in 1:K){
#Splittelés
train_index_loop <- createDataPartition(heart_kesz$HeartDisease,p=0.7,list = FALSE)
heart_kesz_train_loop <- heart_kesz[train_index_loop,]
heart_kesz_test_loop <- heart_kesz[-train_index_loop,]
#Neurális háló tanítása
tryCatch({
ANN_looped <- neuralnet(as.factor(HeartDisease)~., data = heart_kesz_train_loop,hidden=c(5,3),linear.output = FALSE,stepmax=1e4)
#Becslés
pred_loop <- predict(ANN_looped,heart_kesz_test_loop)[,2] %>% round(3)
pred_loop <- sapply(pred_loop,classifier,cut_off=selected_cut_off)
#Eredmények feljegyzése
cfm_looped <- confusionMatrix(data = factor(pred_loop), reference = factor(heart_kesz_test_loop$HeartDisease), mode = "prec_recall")
ANN_Accuracy <- rbind(ANN_Accuracy,cfm_looped$overall[1])
ANN_Precision <- rbind(ANN_Precision,cfm_looped$byClass[5])
ANN_Recall <- rbind(ANN_Recall,cfm_looped$byClass[6])
ANN_F1 <- rbind(ANN_F1,cfm_looped$byClass[7])
},
error=function(e){})
print(i*100/K)
}
selected_cut_off=0.5 #Ez lesz a választott cut-offunk, de tapasztalatok szerint a becsült bináris adat nagyon ritkán esik túl távol 0-tól vagy 1-től, így a 0.1 vagy 0.9-es cut-off ugyanazt az eredményt nyújtja
ANN_Accuracy = array()
ANN_Precision = array()
ANN_Recall = array()
ANN_F1 = array()
K=100
for (i in 1:K){
#Splittelés
train_index_loop <- createDataPartition(heart_kesz$HeartDisease,p=0.7,list = FALSE)
heart_kesz_train_loop <- heart_kesz[train_index_loop,]
heart_kesz_test_loop <- heart_kesz[-train_index_loop,]
#Neurális háló tanítása
tryCatch({
ANN_looped <- neuralnet(as.factor(HeartDisease)~., data = heart_kesz_train_loop,hidden=c(5,3),linear.output = FALSE,stepmax=100000,learningrate = 0.1)
#Becslés
pred_loop <- predict(ANN_looped,heart_kesz_test_loop)[,2] %>% round(3)
pred_loop <- sapply(pred_loop,classifier,cut_off=selected_cut_off)
#Eredmények feljegyzése
cfm_looped <- confusionMatrix(data = factor(pred_loop), reference = factor(heart_kesz_test_loop$HeartDisease), mode = "prec_recall")
ANN_Accuracy <- rbind(ANN_Accuracy,cfm_looped$overall[1])
ANN_Precision <- rbind(ANN_Precision,cfm_looped$byClass[5])
ANN_Recall <- rbind(ANN_Recall,cfm_looped$byClass[6])
ANN_F1 <- rbind(ANN_F1,cfm_looped$byClass[7])
},
error=function(e){})
print(i*100/K)
}
selected_cut_off=0.5 #Ez lesz a választott cut-offunk, de tapasztalatok szerint a becsült bináris adat nagyon ritkán esik túl távol 0-tól vagy 1-től, így a 0.1 vagy 0.9-es cut-off ugyanazt az eredményt nyújtja
ANN_Accuracy = array()
ANN_Precision = array()
ANN_Recall = array()
ANN_F1 = array()
K=100
for (i in 1:K){
#Splittelés
train_index_loop <- createDataPartition(heart_kesz$HeartDisease,p=0.7,list = FALSE)
heart_kesz_train_loop <- heart_kesz[train_index_loop,]
heart_kesz_test_loop <- heart_kesz[-train_index_loop,]
#Neurális háló tanítása
tryCatch({
ANN_looped <- neuralnet(as.factor(HeartDisease)~., data = heart_kesz_train_loop,hidden=4,linear.output = FALSE,stepmax=100000,learningrate = 0.1)
#Becslés
pred_loop <- predict(ANN_looped,heart_kesz_test_loop)[,2] %>% round(3)
pred_loop <- sapply(pred_loop,classifier,cut_off=selected_cut_off)
#Eredmények feljegyzése
cfm_looped <- confusionMatrix(data = factor(pred_loop), reference = factor(heart_kesz_test_loop$HeartDisease), mode = "prec_recall")
ANN_Accuracy <- rbind(ANN_Accuracy,cfm_looped$overall[1])
ANN_Precision <- rbind(ANN_Precision,cfm_looped$byClass[5])
ANN_Recall <- rbind(ANN_Recall,cfm_looped$byClass[6])
ANN_F1 <- rbind(ANN_F1,cfm_looped$byClass[7])
},
error=function(e){})
print(i*100/K)
}
#K soros mérőszám mátrix:
metrics <- cbind(ANN_Accuracy,ANN_Precision, ANN_Recall, ANN_F1)[2:(i+1),]
K
ANN_Accuracy
i
#K soros mérőszám mátrix:
metrics <- cbind(ANN_Accuracy,ANN_Precision, ANN_Recall, ANN_F1)[2:length(ANN_Accuracy),]
#A K sor átlaga - egy sorvektor:
average_metrics <- apply(metrics,2,mean)
metrics
average_metrics
selected_cut_off=0.5 #Ez lesz a választott cut-offunk, de tapasztalatok szerint a becsült bináris adat nagyon ritkán esik túl távol 0-tól vagy 1-től, így a 0.1 vagy 0.9-es cut-off ugyanazt az eredményt nyújtja
K=100
n=4
for (neuronszam in 1:n){
ANN_Accuracy = array()
ANN_Precision = array()
ANN_Recall = array()
ANN_F1 = array()
for (i in 1:K){
#Splittelés
train_index_loop <- createDataPartition(heart_kesz$HeartDisease,p=0.7,list = FALSE)
heart_kesz_train_loop <- heart_kesz[train_index_loop,]
heart_kesz_test_loop <- heart_kesz[-train_index_loop,]
#Neurális háló tanítása
tryCatch({
ANN_looped <- neuralnet(as.factor(HeartDisease)~., data = heart_kesz_train_loop,hidden=neuronszam,linear.output = FALSE,stepmax=100000,learningrate = 0.1)
#Becslés
pred_loop <- predict(ANN_looped,heart_kesz_test_loop)[,2] %>% round(3)
pred_loop <- sapply(pred_loop,classifier,cut_off=selected_cut_off)
#Eredmények feljegyzése
cfm_looped <- confusionMatrix(data = factor(pred_loop), reference = factor(heart_kesz_test_loop$HeartDisease), mode = "prec_recall")
ANN_Accuracy <- rbind(ANN_Accuracy,cfm_looped$overall[1])
ANN_Precision <- rbind(ANN_Precision,cfm_looped$byClass[5])
ANN_Recall <- rbind(ANN_Recall,cfm_looped$byClass[6])
ANN_F1 <- rbind(ANN_F1,cfm_looped$byClass[7])
},
error=function(e){})
print(cbind(i*100/K,"n =", neuronszam))
}
#K soros mérőszám mátrix:
metrics <- cbind(ANN_Accuracy,ANN_Precision, ANN_Recall, ANN_F1)[2:length(ANN_Accuracy),]
#A K sor átlaga - egy sorvektor:
if (neuronszam == 1)
{average_metrics_1 <- apply(metrics,2,mean)}elseif(neuronszam==2)
selected_cut_off=0.5 #Ez lesz a választott cut-offunk, de tapasztalatok szerint a becsült bináris adat nagyon ritkán esik túl távol 0-tól vagy 1-től, így a 0.1 vagy 0.9-es cut-off ugyanazt az eredményt nyújtja
K=100
n=4
for (neuronszam in 1:n){
ANN_Accuracy = array()
ANN_Precision = array()
ANN_Recall = array()
ANN_F1 = array()
for (i in 1:K){
#Splittelés
train_index_loop <- createDataPartition(heart_kesz$HeartDisease,p=0.7,list = FALSE)
heart_kesz_train_loop <- heart_kesz[train_index_loop,]
heart_kesz_test_loop <- heart_kesz[-train_index_loop,]
#Neurális háló tanítása
tryCatch({
ANN_looped <- neuralnet(as.factor(HeartDisease)~., data = heart_kesz_train_loop,hidden=neuronszam,linear.output = FALSE,stepmax=100000,learningrate = 0.1)
#Becslés
pred_loop <- predict(ANN_looped,heart_kesz_test_loop)[,2] %>% round(3)
pred_loop <- sapply(pred_loop,classifier,cut_off=selected_cut_off)
#Eredmények feljegyzése
cfm_looped <- confusionMatrix(data = factor(pred_loop), reference = factor(heart_kesz_test_loop$HeartDisease), mode = "prec_recall")
ANN_Accuracy <- rbind(ANN_Accuracy,cfm_looped$overall[1])
ANN_Precision <- rbind(ANN_Precision,cfm_looped$byClass[5])
ANN_Recall <- rbind(ANN_Recall,cfm_looped$byClass[6])
ANN_F1 <- rbind(ANN_F1,cfm_looped$byClass[7])
},
error=function(e){})
print(cbind(i*100/K,"n =", neuronszam))
}
#K soros mérőszám mátrix:
metrics <- cbind(ANN_Accuracy,ANN_Precision, ANN_Recall, ANN_F1)[2:length(ANN_Accuracy),]
#A K sor átlaga - egy sorvektor:
if (neuronszam == 1)
{average_metrics_1 <- apply(metrics,2,mean)}else if(neuronszam==2)
{average_metrics_2 <- apply(metrics,2,mean)}else if(neuronszam==3)
{average_metrics_3 <- apply(metrics,2,mean)}else
{average_metrics_4 <- apply(metrics,2,mean)}
average_metrics <- rbind(average_metrics_1,average_metrics_2,average_metrics_3,average_metrics_4)
}
selected_cut_off=0.5 #Ez lesz a választott cut-offunk, de tapasztalatok szerint a becsült bináris adat nagyon ritkán esik túl távol 0-tól vagy 1-től, így a 0.1 vagy 0.9-es cut-off ugyanazt az eredményt nyújtja
K=100
n=4
for (neuronszam in 1:n){
ANN_Accuracy = array()
ANN_Precision = array()
ANN_Recall = array()
ANN_F1 = array()
for (i in 1:K){
#Splittelés
train_index_loop <- createDataPartition(heart_kesz$HeartDisease,p=0.7,list = FALSE)
heart_kesz_train_loop <- heart_kesz[train_index_loop,]
heart_kesz_test_loop <- heart_kesz[-train_index_loop,]
#Neurális háló tanítása
tryCatch({
ANN_looped <- neuralnet(as.factor(HeartDisease)~., data = heart_kesz_train_loop,hidden=neuronszam,linear.output = FALSE,stepmax=100000,learningrate = 0.1)
#Becslés
pred_loop <- predict(ANN_looped,heart_kesz_test_loop)[,2] %>% round(3)
pred_loop <- sapply(pred_loop,classifier,cut_off=selected_cut_off)
#Eredmények feljegyzése
cfm_looped <- confusionMatrix(data = factor(pred_loop), reference = factor(heart_kesz_test_loop$HeartDisease), mode = "prec_recall")
ANN_Accuracy <- rbind(ANN_Accuracy,cfm_looped$overall[1])
ANN_Precision <- rbind(ANN_Precision,cfm_looped$byClass[5])
ANN_Recall <- rbind(ANN_Recall,cfm_looped$byClass[6])
ANN_F1 <- rbind(ANN_F1,cfm_looped$byClass[7])
},
error=function(e){})
print(cbind(i*100/K,"n =", neuronszam))
}
#K soros mérőszám mátrix:
metrics <- cbind(ANN_Accuracy,ANN_Precision, ANN_Recall, ANN_F1)[2:length(ANN_Accuracy),]
#A K sor átlaga - egy sorvektor:
if (neuronszam == 1)
{average_metrics_1 <- apply(metrics,2,mean)}else if(neuronszam==2)
{average_metrics_2 <- apply(metrics,2,mean)}else if(neuronszam==3)
{average_metrics_3 <- apply(metrics,2,mean)}else
{average_metrics_4 <- apply(metrics,2,mean)}
}
average_metrics <- rbind(average_metrics_1,average_metrics_2,average_metrics_3,average_metrics_4)
average_metrics
average_metrics %>% as.data.frame()
View(average_metrics)
save(average_metrics)
save(average_metrics,file="ANN_metrics.Rda")
load("/Users/david/OneDrive - Corvinus University of Budapest/Suli/5. év/Többváltozós stat/david_bence_petproject/ANN_metrics.Rda")
load("/Users/david/OneDrive - Corvinus University of Budapest/Suli/5. év/Többváltozós stat/david_bence_petproject/ANN_metrics.Rda")
View(average_metrics)
average_metrics_1layer <- rbind(average_metrics_1,average_metrics_2,average_metrics_3,average_metrics_4)
average_metrics_1layer <- average_metrics
save(average_metrics_1layer,file="ANN_metrics_1layer.Rda")
#Webscrapehez
library(rvest)
#dplyr ( %>% miatt)
library(dplyr)
#ANN
library(neuralnet)
library(nnet)
library(fastDummies)
library(caret)
library(cvms)
#Plot
library(GGally)
norm <- function(x) (x-min(x))/(max(x)-min(x))
classifier <- function(x,cut_off=0.5) {
if(x < cut_off){
return(0)
} else {
return(1)
}
}
library(readr)
heart <- read_csv("heart.csv")
heart_kesz <- dummy_cols(heart, remove_selected_columns = TRUE)
heart_kesz <- sapply(heart_kesz, norm) %>% data.frame()
heart_kesz <- heart_kesz[c("HeartDisease","Age", "RestingBP", "Cholesterol", "FastingBS", "MaxHR", "Oldpeak", "Sex_F", "Sex_M" ,  "ChestPainType_ASY", "ChestPainType_ATA", "ChestPainType_NAP", "ChestPainType_TA", "RestingECG_LVH", "RestingECG_Normal", "RestingECG_ST", "ExerciseAngina_N", "ExerciseAngina_Y", "ST_Slope_Down", "ST_Slope_Flat", "ST_Slope_Up")]
#Webscrapehez
library(rvest)
#dplyr ( %>% miatt)
library(dplyr)
#ANN
library(neuralnet)
library(nnet)
library(fastDummies)
library(caret)
library(cvms)
#Plot
library(GGally)
norm <- function(x) (x-min(x))/(max(x)-min(x))
classifier <- function(x,cut_off=0.5) {
if(x < cut_off){
return(0)
} else {
return(1)
}
}
library(readr)
heart <- read_csv("heart.csv")
heart_kesz <- dummy_cols(heart, remove_selected_columns = TRUE)
heart_kesz <- sapply(heart_kesz, norm) %>% data.frame()
heart_kesz <- heart_kesz[c("HeartDisease","Age", "RestingBP", "Cholesterol", "FastingBS", "MaxHR", "Oldpeak", "Sex_F", "Sex_M" ,  "ChestPainType_ASY", "ChestPainType_ATA", "ChestPainType_NAP", "ChestPainType_TA", "RestingECG_LVH", "RestingECG_Normal", "RestingECG_ST", "ExerciseAngina_N", "ExerciseAngina_Y", "ST_Slope_Down", "ST_Slope_Flat", "ST_Slope_Up")]
selected_cut_off=0.5 #Ez lesz a választott cut-offunk, de tapasztalatok szerint a becsült bináris adat nagyon ritkán esik túl távol 0-tól vagy 1-től, így a 0.1 vagy 0.9-es cut-off ugyanazt az eredményt nyújtja
K=100
n=4
for (neuronszam in 1:n){
ANN_Accuracy = array()
ANN_Precision = array()
ANN_Recall = array()
ANN_F1 = array()
for (i in 1:K){
#Splittelés
train_index_loop <- createDataPartition(heart_kesz$HeartDisease,p=0.7,list = FALSE)
heart_kesz_train_loop <- heart_kesz[train_index_loop,]
heart_kesz_test_loop <- heart_kesz[-train_index_loop,]
#Neurális háló tanítása
tryCatch({
ANN_looped <- neuralnet(as.factor(HeartDisease)~., data = heart_kesz_train_loop,hidden=neuronszam,linear.output = FALSE,stepmax=100000,learningrate = 0.1)
#Becslés
pred_loop <- predict(ANN_looped,heart_kesz_test_loop)[,2] %>% round(3)
pred_loop <- sapply(pred_loop,classifier,cut_off=selected_cut_off)
#Eredmények feljegyzése
cfm_looped <- confusionMatrix(data = factor(pred_loop), reference = factor(heart_kesz_test_loop$HeartDisease), mode = "prec_recall")
ANN_Accuracy <- rbind(ANN_Accuracy,cfm_looped$overall[1])
ANN_Precision <- rbind(ANN_Precision,cfm_looped$byClass[5])
ANN_Recall <- rbind(ANN_Recall,cfm_looped$byClass[6])
ANN_F1 <- rbind(ANN_F1,cfm_looped$byClass[7])
},
error=function(e){})
print(cbind(i*100/K,"n =", neuronszam))
}
#K soros mérőszám mátrix:
metrics <- cbind(ANN_Accuracy,ANN_Precision, ANN_Recall, ANN_F1)[2:length(ANN_Accuracy),]
#A K sor átlaga - egy sorvektor:
if (neuronszam == 1)
{average_metrics_1 <- apply(metrics,2,mean)}else if(neuronszam==2)
{average_metrics_2 <- apply(metrics,2,mean)}else if(neuronszam==3)
{average_metrics_3 <- apply(metrics,2,mean)}else
{average_metrics_4 <- apply(metrics,2,mean)}
}
