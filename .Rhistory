library(neuralnet)
library(nnet)
library(fastDummies)
library(caret)
library(cvms)
#Plot
library(GGally)
norm <- function(x) (x-min(x))/(max(x)-min(x))
classifier <- function(x,cut_off=0.5) {
if(x < cut_off){
return(0)
} else {
return(1)
}
}
library(readr)
heart <- read_csv("heart.csv")
heart_kesz <- dummy_cols(heart, remove_selected_columns = TRUE)
heart_kesz <- sapply(heart_kesz, norm) %>% data.frame()
heart_kesz <- heart_kesz[c("HeartDisease","Age", "RestingBP", "Cholesterol", "FastingBS", "MaxHR", "Oldpeak", "Sex_F", "Sex_M" ,  "ChestPainType_ASY", "ChestPainType_ATA", "ChestPainType_NAP", "ChestPainType_TA", "RestingECG_LVH", "RestingECG_Normal", "RestingECG_ST", "ExerciseAngina_N", "ExerciseAngina_Y", "ST_Slope_Down", "ST_Slope_Flat", "ST_Slope_Up")]
selected_cut_off=0.5 #Ez lesz a választott cut-offunk, de tapasztalatok szerint a becsült bináris adat nagyon ritkán esik túl távol 0-tól vagy 1-től, így a 0.1 vagy 0.9-es cut-off ugyanazt az eredményt nyújtja
K=100
n=4
for (neuronszam in 1:n){
ANN_Accuracy = array()
ANN_Precision = array()
ANN_Recall = array()
ANN_F1 = array()
for (i in 1:K){
#Splittelés
train_index_loop <- createDataPartition(heart_kesz$HeartDisease,p=0.7,list = FALSE)
heart_kesz_train_loop <- heart_kesz[train_index_loop,]
heart_kesz_test_loop <- heart_kesz[-train_index_loop,]
#Neurális háló tanítása
tryCatch({
ANN_looped <- neuralnet(as.factor(HeartDisease)~., data = heart_kesz_train_loop,hidden=neuronszam,linear.output = FALSE,stepmax=100000,learningrate = 0.1)
#Becslés
pred_loop <- predict(ANN_looped,heart_kesz_test_loop)[,2] %>% round(3)
pred_loop <- sapply(pred_loop,classifier,cut_off=selected_cut_off)
#Eredmények feljegyzése
cfm_looped <- confusionMatrix(data = factor(pred_loop), reference = factor(heart_kesz_test_loop$HeartDisease), mode = "prec_recall")
ANN_Accuracy <- rbind(ANN_Accuracy,cfm_looped$overall[1])
ANN_Precision <- rbind(ANN_Precision,cfm_looped$byClass[5])
ANN_Recall <- rbind(ANN_Recall,cfm_looped$byClass[6])
ANN_F1 <- rbind(ANN_F1,cfm_looped$byClass[7])
},
error=function(e){})
print(cbind(i*100/K,"n =", neuronszam))
}
#K soros mérőszám mátrix:
metrics <- cbind(ANN_Accuracy,ANN_Precision, ANN_Recall, ANN_F1)[2:length(ANN_Accuracy),]
#A K sor átlaga - egy sorvektor:
if (neuronszam == 1)
{average_metrics_1 <- apply(metrics,2,mean)}else if(neuronszam==2)
{average_metrics_2 <- apply(metrics,2,mean)}else if(neuronszam==3)
{average_metrics_3 <- apply(metrics,2,mean)}else
{average_metrics_4 <- apply(metrics,2,mean)}
}
selected_cut_off=0.5 #Ez lesz a választott cut-offunk, de tapasztalatok szerint a becsült bináris adat nagyon ritkán esik túl távol 0-tól vagy 1-től, így a 0.1 vagy 0.9-es cut-off ugyanazt az eredményt nyújtja
K=50
n1=3
n2=2
for (neuronszam1 in 1:n1){
for (neuronszam2 in 1:n2){
ANN_Accuracy = array()
ANN_Precision = array()
ANN_Recall = array()
ANN_F1 = array()
for (i in 1:K){
#Splittelés
train_index_loop <- createDataPartition(heart_kesz$HeartDisease,p=0.7,list = FALSE)
heart_kesz_train_loop <- heart_kesz[train_index_loop,]
heart_kesz_test_loop <- heart_kesz[-train_index_loop,]
#Neurális háló tanítása
tryCatch({
ANN_looped <- neuralnet(as.factor(HeartDisease)~., data = heart_kesz_train_loop,hidden=c(neuronszam1,neuronszam2),linear.output = FALSE,stepmax=100000,learningrate = 0.1)
#Becslés
pred_loop <- predict(ANN_looped,heart_kesz_test_loop)[,2] %>% round(3)
pred_loop <- sapply(pred_loop,classifier,cut_off=selected_cut_off)
#Eredmények feljegyzése
cfm_looped <- confusionMatrix(data = factor(pred_loop), reference = factor(heart_kesz_test_loop$HeartDisease), mode = "prec_recall")
ANN_Accuracy <- rbind(ANN_Accuracy,cfm_looped$overall[1])
ANN_Precision <- rbind(ANN_Precision,cfm_looped$byClass[5])
ANN_Recall <- rbind(ANN_Recall,cfm_looped$byClass[6])
ANN_F1 <- rbind(ANN_F1,cfm_looped$byClass[7])
},
error=function(e){})
print(paste0(i*100/K,"%, n1 = ", neuronszam1,", n2 = ",neuronszam2))
}
#K soros mérőszám mátrix:
metrics <- cbind(ANN_Accuracy,ANN_Precision, ANN_Recall, ANN_F1)[2:length(ANN_Accuracy),]
#A K sor átlaga - egy sorvektor:
if(neuronszam1==1 & neuronszam2==1)
{average_metrics_11 <- apply(metrics,2,mean)}else if(neuronszam1==1 & neuronszam2==2)
{average_metrics_12 <- apply(metrics,2,mean)}else if(neuronszam1==2 & neuronszam2==1)
{average_metrics_21 <- apply(metrics,2,mean)}else if(neuronszam1==2 & neuronszam2==2)
{average_metrics_22 <- apply(metrics,2,mean)}else if(neuronszam1==3 & neuronszam2==1)
{average_metrics_31 <- apply(metrics,2,mean)}else
{average_metrics_32 <- apply(metrics,2,mean)}
}
}
#Webscrapehez
library(rvest)
#dplyr ( %>% miatt)
library(dplyr)
#ANN
library(neuralnet)
library(nnet)
library(fastDummies)
library(caret)
library(cvms)
#Plot
library(GGally)
norm <- function(x) (x-min(x))/(max(x)-min(x))
classifier <- function(x,cut_off=0.5) {
if(x < cut_off){
return(0)
} else {
return(1)
}
}
library(readr)
heart <- read_csv("heart.csv")
heart_kesz <- dummy_cols(heart, remove_selected_columns = TRUE)
heart_kesz <- sapply(heart_kesz, norm) %>% data.frame()
heart_kesz <- heart_kesz[c("HeartDisease","Age", "RestingBP", "Cholesterol", "FastingBS", "MaxHR", "Oldpeak", "Sex_F", "Sex_M" ,  "ChestPainType_ASY", "ChestPainType_ATA", "ChestPainType_NAP", "ChestPainType_TA", "RestingECG_LVH", "RestingECG_Normal", "RestingECG_ST", "ExerciseAngina_N", "ExerciseAngina_Y", "ST_Slope_Down", "ST_Slope_Flat", "ST_Slope_Up")]
selected_cut_off=0.5 #Ez lesz a választott cut-offunk, de tapasztalatok szerint a becsült bináris adat nagyon ritkán esik túl távol 0-tól vagy 1-től, így a 0.1 vagy 0.9-es cut-off ugyanazt az eredményt nyújtja
K=50
n1=3
n2=2
for (neuronszam1 in 1:n1){
for (neuronszam2 in 1:n2){
ANN_Accuracy = array()
ANN_Precision = array()
ANN_Recall = array()
ANN_F1 = array()
for (i in 1:K){
#Splittelés
train_index_loop <- createDataPartition(heart_kesz$HeartDisease,p=0.7,list = FALSE)
heart_kesz_train_loop <- heart_kesz[train_index_loop,]
heart_kesz_test_loop <- heart_kesz[-train_index_loop,]
#Neurális háló tanítása
tryCatch({
ANN_looped <- neuralnet(as.factor(HeartDisease)~., data = heart_kesz_train_loop,hidden=c(neuronszam1,neuronszam2),linear.output = FALSE,stepmax=100000,learningrate = 0.1)
#Becslés
pred_loop <- predict(ANN_looped,heart_kesz_test_loop)[,2] %>% round(3)
pred_loop <- sapply(pred_loop,classifier,cut_off=selected_cut_off)
#Eredmények feljegyzése
cfm_looped <- confusionMatrix(data = factor(pred_loop), reference = factor(heart_kesz_test_loop$HeartDisease), mode = "prec_recall")
ANN_Accuracy <- rbind(ANN_Accuracy,cfm_looped$overall[1])
ANN_Precision <- rbind(ANN_Precision,cfm_looped$byClass[5])
ANN_Recall <- rbind(ANN_Recall,cfm_looped$byClass[6])
ANN_F1 <- rbind(ANN_F1,cfm_looped$byClass[7])
},
error=function(e){})
print(paste0(i*100/K,"%, n1 = ", neuronszam1,", n2 = ",neuronszam2))
}
#K soros mérőszám mátrix:
metrics <- cbind(ANN_Accuracy,ANN_Precision, ANN_Recall, ANN_F1)[2:length(ANN_Accuracy),]
#A K sor átlaga - egy sorvektor:
if(neuronszam1==1 & neuronszam2==1)
{average_metrics_11 <- apply(metrics,2,mean)}else if(neuronszam1==1 & neuronszam2==2)
{average_metrics_12 <- apply(metrics,2,mean)}else if(neuronszam1==2 & neuronszam2==1)
{average_metrics_21 <- apply(metrics,2,mean)}else if(neuronszam1==2 & neuronszam2==2)
{average_metrics_22 <- apply(metrics,2,mean)}else if(neuronszam1==3 & neuronszam2==1)
{average_metrics_31 <- apply(metrics,2,mean)}else
{average_metrics_32 <- apply(metrics,2,mean)}
}
}
average_metrics_2layer <- rbind(average_metrics_11,average_metrics_12,average_metrics_21,average_metrics_22,average_metrics_31,average_metrics_32) %>% as.data.frame()
save(average_metrics_2layer,file="ANN_metrics_2layer.Rda")
load("~/OneDrive - Corvinus University of Budapest/Suli/5. év/Többváltozós stat/david_bence_petproject/ANN_metrics_2layer.Rda")
load("~/OneDrive - Corvinus University of Budapest/Suli/5. év/Többváltozós stat/david_bence_petproject/ANN_metrics_2layer.Rda")
View(average_metrics_2layer)
selected_cut_off=0.5 #Ez lesz a választott cut-offunk, de tapasztalatok szerint a becsült bináris adat nagyon ritkán esik túl távol 0-tól vagy 1-től, így a 0.1 vagy 0.9-es cut-off ugyanazt az eredményt nyújtja
K=50
n1=1
n2=1
for (neuronszam1 in 1:n1){
for (neuronszam2 in 1:n2){
ANN_Accuracy = array()
ANN_Precision = array()
ANN_Recall = array()
ANN_F1 = array()
for (i in 1:K){
#Splittelés
train_index_loop <- createDataPartition(heart_kesz$HeartDisease,p=0.7,list = FALSE)
heart_kesz_train_loop <- heart_kesz[train_index_loop,]
heart_kesz_test_loop <- heart_kesz[-train_index_loop,]
#Neurális háló tanítása
tryCatch({
ANN_looped <- neuralnet(as.factor(HeartDisease)~., data = heart_kesz_train_loop,hidden=c(neuronszam1,neuronszam2),linear.output = FALSE,stepmax=100000,learningrate = 0.1)
#Becslés
pred_loop <- predict(ANN_looped,heart_kesz_test_loop)[,2] %>% round(3)
pred_loop <- sapply(pred_loop,classifier,cut_off=selected_cut_off)
#Eredmények feljegyzése
cfm_looped <- confusionMatrix(data = factor(pred_loop), reference = factor(heart_kesz_test_loop$HeartDisease), mode = "prec_recall")
ANN_Accuracy <- rbind(ANN_Accuracy,cfm_looped$overall[1])
ANN_Precision <- rbind(ANN_Precision,cfm_looped$byClass[5])
ANN_Recall <- rbind(ANN_Recall,cfm_looped$byClass[6])
ANN_F1 <- rbind(ANN_F1,cfm_looped$byClass[7])
},
error=function(e){})
print(paste0(i*100/K,"%, n1 = ", neuronszam1,", n2 = ",neuronszam2))
}
#K soros mérőszám mátrix:
metrics <- cbind(ANN_Accuracy,ANN_Precision, ANN_Recall, ANN_F1)[2:length(ANN_Accuracy),]
#A K sor átlaga - egy sorvektor:
if(neuronszam1==1 & neuronszam2==1)
{average_metrics_11 <- apply(metrics,2,mean)}else if(neuronszam1==1 & neuronszam2==2)
{average_metrics_12 <- apply(metrics,2,mean)}else if(neuronszam1==2 & neuronszam2==1)
{average_metrics_21 <- apply(metrics,2,mean)}else if(neuronszam1==2 & neuronszam2==2)
{average_metrics_22 <- apply(metrics,2,mean)}else if(neuronszam1==3 & neuronszam2==1)
{average_metrics_31 <- apply(metrics,2,mean)}else
{average_metrics_32 <- apply(metrics,2,mean)}
}
}
selected_cut_off=0.5 #Ez lesz a választott cut-offunk, de tapasztalatok szerint a becsült bináris adat nagyon ritkán esik túl távol 0-tól vagy 1-től, így a 0.1 vagy 0.9-es cut-off ugyanazt az eredményt nyújtja
K=50
n1=1
n2=1
neuronszam1=1
neuronszam2=1
#for (neuronszam1 in 1:n1){
#for (neuronszam2 in 1:n2){
ANN_Accuracy = array()
ANN_Precision = array()
ANN_Recall = array()
ANN_F1 = array()
for (i in 1:K){
#Splittelés
train_index_loop <- createDataPartition(heart_kesz$HeartDisease,p=0.7,list = FALSE)
heart_kesz_train_loop <- heart_kesz[train_index_loop,]
heart_kesz_test_loop <- heart_kesz[-train_index_loop,]
#Neurális háló tanítása
tryCatch({
ANN_looped <- neuralnet(as.factor(HeartDisease)~., data = heart_kesz_train_loop,hidden=c(neuronszam1,neuronszam2),linear.output = FALSE,stepmax=100000,learningrate = 0.1)
#Becslés
pred_loop <- predict(ANN_looped,heart_kesz_test_loop)[,2] %>% round(3)
pred_loop <- sapply(pred_loop,classifier,cut_off=selected_cut_off)
#Eredmények feljegyzése
cfm_looped <- confusionMatrix(data = factor(pred_loop), reference = factor(heart_kesz_test_loop$HeartDisease), mode = "prec_recall")
ANN_Accuracy <- rbind(ANN_Accuracy,cfm_looped$overall[1])
ANN_Precision <- rbind(ANN_Precision,cfm_looped$byClass[5])
ANN_Recall <- rbind(ANN_Recall,cfm_looped$byClass[6])
ANN_F1 <- rbind(ANN_F1,cfm_looped$byClass[7])
},
error=function(e){})
print(paste0(i*100/K,"%, n1 = ", neuronszam1,", n2 = ",neuronszam2))
}
#Webscrapehez
library(rvest)
#dplyr ( %>% miatt)
library(dplyr)
#ANN
library(neuralnet)
library(nnet)
library(fastDummies)
library(caret)
library(cvms)
#Plot
library(GGally)
norm <- function(x) (x-min(x))/(max(x)-min(x))
classifier <- function(x,cut_off=0.5) {
if(x < cut_off){
return(0)
} else {
return(1)
}
}
library(readr)
heart <- read_csv("heart.csv")
heart_kesz <- dummy_cols(heart, remove_selected_columns = TRUE)
heart_kesz <- sapply(heart_kesz, norm) %>% data.frame()
heart_kesz <- heart_kesz[c("HeartDisease","Age", "RestingBP", "Cholesterol", "FastingBS", "MaxHR", "Oldpeak", "Sex_F", "Sex_M" ,  "ChestPainType_ASY", "ChestPainType_ATA", "ChestPainType_NAP", "ChestPainType_TA", "RestingECG_LVH", "RestingECG_Normal", "RestingECG_ST", "ExerciseAngina_N", "ExerciseAngina_Y", "ST_Slope_Down", "ST_Slope_Flat", "ST_Slope_Up")]
selected_cut_off=0.5 #Ez lesz a választott cut-offunk, de tapasztalatok szerint a becsült bináris adat nagyon ritkán esik túl távol 0-tól vagy 1-től, így a 0.1 vagy 0.9-es cut-off ugyanazt az eredményt nyújtja
K=50
n1=1
n2=1
neuronszam1=1
neuronszam2=1
#for (neuronszam1 in 1:n1){
#for (neuronszam2 in 1:n2){
ANN_Accuracy = array()
ANN_Precision = array()
ANN_Recall = array()
ANN_F1 = array()
for (i in 1:K){
#Splittelés
train_index_loop <- createDataPartition(heart_kesz$HeartDisease,p=0.7,list = FALSE)
heart_kesz_train_loop <- heart_kesz[train_index_loop,]
heart_kesz_test_loop <- heart_kesz[-train_index_loop,]
#Neurális háló tanítása
tryCatch({
ANN_looped <- neuralnet(as.factor(HeartDisease)~., data = heart_kesz_train_loop,hidden=c(neuronszam1,neuronszam2),linear.output = FALSE,stepmax=100000,learningrate = 0.1)
#Becslés
pred_loop <- predict(ANN_looped,heart_kesz_test_loop)[,2] %>% round(3)
pred_loop <- sapply(pred_loop,classifier,cut_off=selected_cut_off)
#Eredmények feljegyzése
cfm_looped <- confusionMatrix(data = factor(pred_loop), reference = factor(heart_kesz_test_loop$HeartDisease), mode = "prec_recall")
ANN_Accuracy <- rbind(ANN_Accuracy,cfm_looped$overall[1])
ANN_Precision <- rbind(ANN_Precision,cfm_looped$byClass[5])
ANN_Recall <- rbind(ANN_Recall,cfm_looped$byClass[6])
ANN_F1 <- rbind(ANN_F1,cfm_looped$byClass[7])
},
error=function(e){})
print(paste0(i*100/K,"%, n1 = ", neuronszam1,", n2 = ",neuronszam2))
}
#K soros mérőszám mátrix:
metrics <- cbind(ANN_Accuracy,ANN_Precision, ANN_Recall, ANN_F1)[2:length(ANN_Accuracy),]
#A K sor átlaga - egy sorvektor:
if(neuronszam1==1 & neuronszam2==1)
{average_metrics_11 <- apply(metrics,2,mean)}else if(neuronszam1==1 & neuronszam2==2)
{average_metrics_12 <- apply(metrics,2,mean)}else if(neuronszam1==2 & neuronszam2==1)
{average_metrics_21 <- apply(metrics,2,mean)}else if(neuronszam1==2 & neuronszam2==2)
{average_metrics_22 <- apply(metrics,2,mean)}else if(neuronszam1==3 & neuronszam2==1)
{average_metrics_31 <- apply(metrics,2,mean)}else
{average_metrics_32 <- apply(metrics,2,mean)}
#}
#}
average_metrics_2layer_11 <- rbind(average_metrics_11,average_metrics_12,average_metrics_21,average_metrics_22,average_metrics_31,average_metrics_32) %>% as.data.frame()
average_metrics_11
selected_cut_off=0.5 #Ez lesz a választott cut-offunk, de tapasztalatok szerint a becsült bináris adat nagyon ritkán esik túl távol 0-tól vagy 1-től, így a 0.1 vagy 0.9-es cut-off ugyanazt az eredményt nyújtja
K=25
n1=1
n2=1
neuronszam1=1
neuronszam2=1
#for (neuronszam1 in 1:n1){
#for (neuronszam2 in 1:n2){
ANN_Accuracy = array()
ANN_Precision = array()
ANN_Recall = array()
ANN_F1 = array()
for (i in 1:K){
#Splittelés
train_index_loop <- createDataPartition(heart_kesz$HeartDisease,p=0.7,list = FALSE)
heart_kesz_train_loop <- heart_kesz[train_index_loop,]
heart_kesz_test_loop <- heart_kesz[-train_index_loop,]
#Neurális háló tanítása
tryCatch({
ANN_looped <- neuralnet(as.factor(HeartDisease)~., data = heart_kesz_train_loop,hidden=c(neuronszam1,neuronszam2),linear.output = FALSE,stepmax=100000,learningrate = 0.1)
#Becslés
pred_loop <- predict(ANN_looped,heart_kesz_test_loop)[,2] %>% round(3)
pred_loop <- sapply(pred_loop,classifier,cut_off=selected_cut_off)
#Eredmények feljegyzése
cfm_looped <- confusionMatrix(data = factor(pred_loop), reference = factor(heart_kesz_test_loop$HeartDisease), mode = "prec_recall")
ANN_Accuracy <- rbind(ANN_Accuracy,cfm_looped$overall[1])
ANN_Precision <- rbind(ANN_Precision,cfm_looped$byClass[5])
ANN_Recall <- rbind(ANN_Recall,cfm_looped$byClass[6])
ANN_F1 <- rbind(ANN_F1,cfm_looped$byClass[7])
},
error=function(e){})
print(paste0(i*100/K,"%, n1 = ", neuronszam1,", n2 = ",neuronszam2))
}
#K soros mérőszám mátrix:
metrics <- cbind(ANN_Accuracy,ANN_Precision, ANN_Recall, ANN_F1)[2:length(ANN_Accuracy),]
#A K sor átlaga - egy sorvektor:
if(neuronszam1==1 & neuronszam2==1)
{average_metrics_11 <- apply(metrics,2,mean)}else if(neuronszam1==1 & neuronszam2==2)
{average_metrics_12 <- apply(metrics,2,mean)}else if(neuronszam1==2 & neuronszam2==1)
{average_metrics_21 <- apply(metrics,2,mean)}else if(neuronszam1==2 & neuronszam2==2)
{average_metrics_22 <- apply(metrics,2,mean)}else if(neuronszam1==3 & neuronszam2==1)
{average_metrics_31 <- apply(metrics,2,mean)}else
{average_metrics_32 <- apply(metrics,2,mean)}
#}
#}
average_metrics_2layer <- rbind(average_metrics_11,average_metrics_12,average_metrics_21,average_metrics_22,average_metrics_31,average_metrics_32) %>% as.data.frame()
average_metrics_11
load("~/OneDrive - Corvinus University of Budapest/Suli/5. év/Többváltozós stat/david_bence_petproject/ANN_metrics_2layer_v1.Rda")
average_metrics_2layer
average_metrics_2layer[1,]
average_metrics_2layer[1,] <- average_metrics_11
average_metrics_2layer
save(average_metrics_2layer,file="ANN_metrics_2layer.Rda")
load("~/OneDrive - Corvinus University of Budapest/Suli/5. év/Többváltozós stat/david_bence_petproject/ANN_metrics_2layer.Rda")
load("~/OneDrive - Corvinus University of Budapest/Suli/5. év/Többváltozós stat/david_bence_petproject/ANN_metrics_1layer.Rda")
View(rbind(average_metrics_1layer,average_metrics_2layer))
selected_cut_off=0.5 #Ez lesz a választott cut-offunk, de tapasztalatok szerint a becsült bináris adat nagyon ritkán esik túl távol 0-tól vagy 1-től, így a 0.1 vagy 0.9-es cut-off ugyanazt az eredményt nyújtja
K=35
n1=3
n2=2
for (neuronszam1 in 1:n1){
for (neuronszam2 in 1:n2){
ANN_Accuracy = array()
ANN_Precision = array()
ANN_Recall = array()
ANN_F1 = array()
for (i in 1:K){
#Splittelés
train_index_loop <- createDataPartition(heart_kesz$HeartDisease,p=0.7,list = FALSE)
heart_kesz_train_loop <- heart_kesz[train_index_loop,]
heart_kesz_test_loop <- heart_kesz[-train_index_loop,]
#Neurális háló tanítása
tryCatch({
ANN_looped <- neuralnet(as.factor(HeartDisease)~., data = heart_kesz_train_loop,hidden=c(neuronszam1,neuronszam2),linear.output = FALSE,stepmax=100000,learningrate = 0.13)
#Becslés
pred_loop <- predict(ANN_looped,heart_kesz_test_loop)[,2] %>% round(3)
pred_loop <- sapply(pred_loop,classifier,cut_off=selected_cut_off)
#Eredmények feljegyzése
cfm_looped <- confusionMatrix(data = factor(pred_loop), reference = factor(heart_kesz_test_loop$HeartDisease), mode = "prec_recall")
ANN_Accuracy <- rbind(ANN_Accuracy,cfm_looped$overall[1])
ANN_Precision <- rbind(ANN_Precision,cfm_looped$byClass[5])
ANN_Recall <- rbind(ANN_Recall,cfm_looped$byClass[6])
ANN_F1 <- rbind(ANN_F1,cfm_looped$byClass[7])
},
error=function(e){})
print(paste0(i*100/K,"%, n1 = ", neuronszam1,", n2 = ",neuronszam2))
}
#K soros mérőszám mátrix:
metrics <- cbind(ANN_Accuracy,ANN_Precision, ANN_Recall, ANN_F1)[2:length(ANN_Accuracy),]
#A K sor átlaga - egy sorvektor:
if(neuronszam1==1 & neuronszam2==1)
{average_metrics_11 <- apply(metrics,2,mean)}else if(neuronszam1==1 & neuronszam2==2)
{average_metrics_12 <- apply(metrics,2,mean)}else if(neuronszam1==2 & neuronszam2==1)
{average_metrics_21 <- apply(metrics,2,mean)}else if(neuronszam1==2 & neuronszam2==2)
{average_metrics_22 <- apply(metrics,2,mean)}else if(neuronszam1==3 & neuronszam2==1)
{average_metrics_31 <- apply(metrics,2,mean)}else
{average_metrics_32 <- apply(metrics,2,mean)}
}
}
average_metrics_2layer <- rbind(average_metrics_11,average_metrics_12,average_metrics_21,average_metrics_22,average_metrics_31,average_metrics_32) %>% as.data.frame()
save(average_metrics_2layer,file="ANN_metrics_2layer.Rda")
save(average_metrics_11,file="ANN_metrics_2layer_11.Rda")
load("~/OneDrive - Corvinus University of Budapest/Suli/5. év/Többváltozós stat/david_bence_petproject/ANN_metrics_2layer.Rda")
average_metrics_2layer
average_metrics_11
average_metrics_1layer
ann_metrics <- rbind(average_metrics_1layer,average_metrics_2layer) %>% save("ANN_metrics.Rda")
ann_metrics <- rbind(average_metrics_1layer,average_metrics_2layer) %>% save(file="ANN_metrics.Rda")
ann_metrics
load("~/OneDrive - Corvinus University of Budapest/Suli/5. év/Többváltozós stat/david_bence_petproject/ANN_metrics.Rda")
ann_metrics
average_metrics_1layer
ann_metrics <- rbind(average_metrics_1layer,average_metrics_2layer)
ann_metrics
save(ann_metrics,file="ANN_metrics.Rda")
load("~/OneDrive - Corvinus University of Budapest/Suli/5. év/Többváltozós stat/david_bence_petproject/ANN_metrics.Rda")
#Webscrapehez
library(rvest)
#dplyr ( %>% miatt)
library(dplyr)
#ANN
library(neuralnet)
library(nnet)
library(fastDummies)
library(caret)
library(cvms)
#Plot
library(GGally)
norm <- function(x) (x-min(x))/(max(x)-min(x))
classifier <- function(x,cut_off=0.5) {
if(x < cut_off){
return(0)
} else {
return(1)
}
}
library(readr)
heart <- read_csv("heart.csv")
heart_kesz <- dummy_cols(heart, remove_selected_columns = TRUE)
heart_kesz <- sapply(heart_kesz, norm) %>% data.frame()
heart_kesz <- heart_kesz[c("HeartDisease","Age", "RestingBP", "Cholesterol", "FastingBS", "MaxHR", "Oldpeak", "Sex_F", "Sex_M" ,  "ChestPainType_ASY", "ChestPainType_ATA", "ChestPainType_NAP", "ChestPainType_TA", "RestingECG_LVH", "RestingECG_Normal", "RestingECG_ST", "ExerciseAngina_N", "ExerciseAngina_Y", "ST_Slope_Down", "ST_Slope_Flat", "ST_Slope_Up")]
set.seed(2021)
train_index <- createDataPartition(heart_kesz$HeartDisease,p=0.7,list = FALSE)
heart_kesz_train <- heart_kesz[train_index,]
heart_kesz_test <- heart_kesz[-train_index,]
ANN_best <- neuralnet(as.factor(HeartDisease)~., data = heart_kesz_train, hidden = c(1,1), linear.output = FALSE)
selected_cut_off=0.5
#A classifier egy az elején definiált függvény, átalakítja pred-et 0-1-esekből álló vektorrá a selected_cut_off-tól függően
pred <- predict(ANN,heart_kesz_test)[,2] %>% round(3)
selected_cut_off=0.5
#A classifier egy az elején definiált függvény, átalakítja pred-et 0-1-esekből álló vektorrá a selected_cut_off-tól függően
pred <- predict(ANN_best,heart_kesz_test)[,2] %>% round(3)
pred <- sapply(pred,classifier,cut_off=selected_cut_off)
conf_matrix<- tibble("prediction"=pred,"target_var" = heart_kesz_test$HeartDisease) %>%
table() %>%
as_tibble() %>%
plot_confusion_matrix(prediction_col = "prediction",
target_col = "target_var",
counts_col = "n",
class_order = c("1","0"))
conf_matrix
hist(heart$HeartDisease)
#Plot
library(ggplot2)
ggplot(heart$HeartDisease)
ggplot(data.frame(heart)$HeartDisease)
heart <- heart %>% as.data.frame()
ggplot(heart$HeartDisease)
ggplot(heart[,1])
ggplot(HeartDisease,data=heart)
ggplot(heart)
heartdisease <- heart$HeartDisease %>% as.data.frame()
ggplot(heartdisease)
cfm <- confusionMatrix(data = factor(pred), reference = factor(heart_kesz_test$HeartDisease), mode = "prec_recall")
cfm$overall[1] #Accuracy
cfm$byClass[5] #Precision
cfm$byClass[6] #Recall
cfm$byClass[7] #F1
bartplot(heart_kesz$HeartDisease)
barplot(heart_kesz$HeartDisease)
ggplot(heart_kesz$HeartDisease)
barplot(heart_kesz$HeartDisease)
heartdiseases <- table(heart_kesz$HeartDisease)
barplot(heartdiseases)
ggplot(heartdiseases)
ggplot(data=heartdiseases)
heartdiseases <- data.frame(table(heart_kesz$HeartDisease))
ggplot(data=heartdiseases)
heartdiseases <- table(heart_kesz$HeartDisease)
barplot(heartdiseases)
