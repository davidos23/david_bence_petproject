---
title: "Ingatlan piac elemzés"
author: "Szabó Bence Dániel, Sklovskiy David"
date: "11/20/2021"
output: html_document
---

## ________________________________________
## Menetrend:
1. Adat leszedése, tisztítása
2. Három módszer alkalmazása:
  a. ANN
  b. Véletlen erdők
  c. Ensemble módszer
3.Összehasonlítás

Cél: pontosan megbecsülni a szívbetegeket a produkált tünetek alapján.

### Adat kiválasztása
A kiválasztott adat a "heart.csv"


### Szükséges package-k betöltése
```{r}
#Webscrapehez
library(rvest)
#dplyr ( %>% miatt)
library(dplyr)

#ANN
library(neuralnet)
library(nnet)
library(fastDummies)
library(caret)
library(cvms)

```

### Segédfüggvények definiálása
```{r}
norm <- function(x) (x-min(x))/(max(x)-min(x))


classifier <- function(x,cut_off=0.5) {
  if(x < cut_off){
    return(0)
  } else {
    return(1)
  }
}
```


### Adat betöltése:
```{r}
library(readr)
heart <- read_csv("heart.csv")
```


Dummy változók átalakítása oszlopokká, normálás:
```{r}
heart_kesz <- dummy_cols(heart, remove_selected_columns = TRUE)
heart_kesz <- sapply(heart_kesz, norm) %>% data.frame()
heart_kesz <- heart_kesz[c("HeartDisease","Age", "RestingBP", "Cholesterol", "FastingBS", "MaxHR", "Oldpeak", "Sex_F", "Sex_M" ,  "ChestPainType_ASY", "ChestPainType_ATA", "ChestPainType_NAP", "ChestPainType_TA", "RestingECG_LVH", "RestingECG_Normal", "RestingECG_ST", "ExerciseAngina_N", "ExerciseAngina_Y", "ST_Slope_Down", "ST_Slope_Flat", "ST_Slope_Up")]
```

___________________________________________________________

###___________________________________________________________
Train-test splites neurális háló:
 - Neurális hálók használatához most a "caret" package-t fogjuk használni
 - Mivel sajnos egy cross-validációs algoritmussal (train("neuralnet",trControl=trControl("cv"))) nem tudtunk elérni konvergens     megoldást, több train-test splitet alkalmazunk az optimális háló megtalálásához.
 - 4 metrikát fogunk megtekinteni a hálók klasszifikációs teljesítményére:
   -> Accuracy (TP + TN / TP + TN + FP + FN)
   -> Recall (TP / TP + FN)
   -> Precision (TP / TP + FP)
   -> F1-mutató (2 * R * P) / (R + P)
A legjobb háló megválasztása elsősorban Accuracy-ja alapján lesz kiválasztva, a többi metrika segédmutatóként szolgál, amennyiben  szükség van másodlagos döntőtényezőre.
 

Adatok splittelése
Adathalmazunkat szétválasztjuk 70%-30% arányban random megválasztott indexekkel:
```{r}
train_index <- createDataPartition(heart_kesz$HeartDisease,p=0.7,list = FALSE)
heart_kesz_train <- heart_kesz[train_index,]
heart_kesz_test <- heart_kesz[-train_index,]
```

A neurális hálónk tehát a következőképpen fog kinézni:
```{r}
ANN <- neuralnet(as.factor(HeartDisease)~., data = heart_kesz_train, hidden = c(2,5), linear.output = FALSE)
```


Becslés:
A következőképp végezzük a becsléseket, és konvertáljuk egy bináris vektorrá. Cut-off-nak tapasztalataink szerint jelen esetben tetszóleges 0 és 1 közötti szám megadható, a becslés rendkívül ritkánt becsül 0 vagy 1-től jelentősen különböző valószínűséget.
```{r}
selected_cut_off=0.5
#A classifier egy az elején definiált függvény, átalakítja pred-et 0-1-esekből álló vektorrá a selected_cut_off-tól függően
pred <- predict(ANN,heart_kesz_test)[,2] %>% round(3)
pred <- sapply(pred,classifier,cut_off=selected_cut_off)
```

Konfúziós mátrix vizualizálva:
```{r}
conf_matrix<- tibble("prediction"=pred,"target_var" = heart_kesz_test$HeartDisease) %>% 
  table() %>%
  as_tibble() %>% 
  plot_confusion_matrix(prediction_col = "prediction",
                      target_col = "target_var", 
                      counts_col = "n",
                      class_order = c("1","0"))

conf_matrix
```
Klasszifikációs mutatók:
```{r}
cfm <- confusionMatrix(data = factor(pred), reference = factor(heart_kesz_test$HeartDisease), mode = "prec_recall")
cfm
```
F1 mutató, ezt akarjuk maximalizálni:
```{r}

cfm$overall[1] #Accuracy
cfm$byClass[5] #Precision
cfm$byClass[6] #Recall
cfm$byClass[7] #F1
```

__________________________________________________________________________________________
A következőben próbáljuk megtalálni az optimális egyrétegű neurális hálót. Mivel a bemeneti neuronok száma 21, és a teljes tanuló mintanagyság 643 (0.7 * 918), ezért a paraméterek számát szeretnénk korlátozni maximum 70-80-ra. Egy 4 neuronos rejtett rétegű hálónál állunk meg (ami (21 * 4) + (4 + 4 * 2) + 2 = 78 paramétert jelent).

K = 100 db különböző split-et fogunk futtatni, n=1:4 neuronos rejtett rétegekre:

Először egy K hosszú random világállapot vektort generálunk:
```{r}
K=100
vilagallapot <- sample(1:5000,K)
```

```{r}
selected_cut_off=0.5 #Ez lesz a választott cut-offunk, de tapasztalatok szerint a becsült bináris adat nagyon ritkán esik túl távol 0-tól vagy 1-től, így a 0.1 vagy 0.9-es cut-off ugyanazt az eredményt nyújtja


n=4
for (neuronszam in 1:n){
  ANN_Accuracy = array()
  ANN_Precision = array()
  ANN_Recall = array()
  ANN_F1 = array()
  for (i in 1:K){
    #i. vilagallapot rögzítése a split előtt
    set.seed(vilagallapot[i])
    
    #Splittelés
    train_index_loop <- createDataPartition(heart_kesz$HeartDisease,p=0.7,list = FALSE)
    heart_kesz_train_loop <- heart_kesz[train_index_loop,]
    heart_kesz_test_loop <- heart_kesz[-train_index_loop,]
    
    #Neurális háló tanítása
    tryCatch({
      ANN_looped <- neuralnet(as.factor(HeartDisease)~., data = heart_kesz_train_loop,hidden=neuronszam,linear.output = FALSE,stepmax=100000,learningrate = 0.1)
    
    
    #Becslés
    pred_loop <- predict(ANN_looped,heart_kesz_test_loop)[,2] %>% round(3)
    pred_loop <- sapply(pred_loop,classifier,cut_off=selected_cut_off)
  
    
    #Eredmények feljegyzése
    cfm_looped <- confusionMatrix(data = factor(pred_loop), reference = factor(heart_kesz_test_loop$HeartDisease), mode = "prec_recall")
    
    ANN_Accuracy <- rbind(ANN_Accuracy,cfm_looped$overall[1])
    ANN_Precision <- rbind(ANN_Precision,cfm_looped$byClass[5])
    ANN_Recall <- rbind(ANN_Recall,cfm_looped$byClass[6])
    ANN_F1 <- rbind(ANN_F1,cfm_looped$byClass[7])
    },
    error=function(e){})
    print(paste0(i*100/K,"%, n = ", neuronszam))
  }

  #K soros mérőszám mátrix:
  metrics <- cbind(ANN_Accuracy,ANN_Precision, ANN_Recall, ANN_F1)[2:length(ANN_Accuracy),]
  
  #A K sor átlaga - egy sorvektor:
  if (neuronszam == 1)
  {average_metrics_1 <- apply(metrics,2,mean,na.rm=TRUE)}else if(neuronszam==2)
  {average_metrics_2 <- apply(metrics,2,mean,na.rm=TRUE)}else if(neuronszam==3)
  {average_metrics_3 <- apply(metrics,2,mean,na.rm=TRUE)}else
  {average_metrics_4 <- apply(metrics,2,mean,na.rm=TRUE)}
}
average_metrics_1layer <- rbind(average_metrics_1,average_metrics_2,average_metrics_3,average_metrics_4)

#save(average_metrics_1layer,file="ANN_metrics_1layer.Rda")

```
A legpontosabb becslést az 1 rejtett rétegú neurális háló esetén az 1db neuronos rejtett rétegű háló adja.

Kettő rejtett réteg esetén a legkomplexebb háló (21-3-2-2) lesz. A neuronszám keresése:
```{r}
selected_cut_off=0.5 #Ez lesz a választott cut-offunk, de tapasztalatok szerint a becsült bináris adat nagyon ritkán esik túl távol 0-tól vagy 1-től, így a 0.1 vagy 0.9-es cut-off ugyanazt az eredményt nyújtja


n1=3
n2=2


for (neuronszam1 in 1:n1){
  for (neuronszam2 in 1:n2){
  ANN_Accuracy = array()
  ANN_Precision = array()
  ANN_Recall = array()
  ANN_F1 = array()
  for (i in 1:K){
    
    #i. vilagallapot rögzítése a split előtt
    set.seed(vilagallapot[i])
    
    #Splittelés
    train_index_loop <- createDataPartition(heart_kesz$HeartDisease,p=0.7,list = FALSE)
    heart_kesz_train_loop <- heart_kesz[train_index_loop,]
    heart_kesz_test_loop <- heart_kesz[-train_index_loop,]
    
    #Neurális háló tanítása
    tryCatch({
      ANN_looped <- neuralnet(as.factor(HeartDisease)~., data = heart_kesz_train_loop,hidden=c(neuronszam1,neuronszam2),linear.output = FALSE,stepmax=100000,learningrate = 0.13)
    
    
    #Becslés
    pred_loop <- predict(ANN_looped,heart_kesz_test_loop)[,2] %>% round(3)
    pred_loop <- sapply(pred_loop,classifier,cut_off=selected_cut_off)
  
    
    #Eredmények feljegyzése
    cfm_looped <- confusionMatrix(data = factor(pred_loop), reference = factor(heart_kesz_test_loop$HeartDisease), mode = "prec_recall")
    
    ANN_Accuracy <- rbind(ANN_Accuracy,cfm_looped$overall[1])
    ANN_Precision <- rbind(ANN_Precision,cfm_looped$byClass[5])
    ANN_Recall <- rbind(ANN_Recall,cfm_looped$byClass[6])
    ANN_F1 <- rbind(ANN_F1,cfm_looped$byClass[7])
    },
    error=function(e){})
    print(paste0(i*100/K,"%, n1 = ", neuronszam1,", n2 = ",neuronszam2))
  }

  #K soros mérőszám mátrix:
  metrics <- cbind(ANN_Accuracy,ANN_Precision, ANN_Recall, ANN_F1)[2:length(ANN_Accuracy),]
  
  #A K sor átlaga - egy sorvektor:
  if(neuronszam1==1 & neuronszam2==1)
  {average_metrics_11 <- apply(metrics,2,mean,na.rm=TRUE)}else if(neuronszam1==1 & neuronszam2==2)
  {average_metrics_12 <- apply(metrics,2,mean,na.rm=TRUE)}else if(neuronszam1==2 & neuronszam2==1)
  {average_metrics_21 <- apply(metrics,2,mean,na.rm=TRUE)}else if(neuronszam1==2 & neuronszam2==2)
  {average_metrics_22 <- apply(metrics,2,mean,na.rm=TRUE)}else if(neuronszam1==3 & neuronszam2==1)
  {average_metrics_31 <- apply(metrics,2,mean,na.rm=TRUE)}else
  {average_metrics_32 <- apply(metrics,2,mean,na.rm=TRUE)}
  }
}
average_metrics_2layer <- rbind(average_metrics_11,average_metrics_12,average_metrics_21,average_metrics_22,average_metrics_31,average_metrics_32) %>% as.data.frame()

#save(average_metrics_2layer,file="ANN_metrics_2layer.Rda")

```

Összekötjük eredményeinket:
```{r}
ann_metrics <- rbind(average_metrics_1layer,average_metrics_2layer)

#save(ann_metrics,file="ANN_metrics.Rda")
```


A legjobb átlagos pontossággal (Accuracy) a [21-1-1-2] nurális háló rendelkezik a fentiek alapján:

Adatok splittelése:
```{r}
set.seed(2021)
train_index <- createDataPartition(heart_kesz$HeartDisease,p=0.7,list = FALSE)
heart_kesz_train <- heart_kesz[train_index,]
heart_kesz_test <- heart_kesz[-train_index,]
```

[1-1]-es neurális háló tanítása: 
```{r}
ANN_best <- neuralnet(as.factor(HeartDisease)~., data = heart_kesz_train, hidden = c(1,1), linear.output = FALSE)
plot(ANN_best)
```

Becslés:
```{r}
selected_cut_off=0.5
#A classifier egy az elején definiált függvény, átalakítja pred-et 0-1-esekből álló vektorrá a selected_cut_off-tól függően
pred <- predict(ANN_best,heart_kesz_test)[,2] %>% round(3)
pred <- sapply(pred,classifier,cut_off=selected_cut_off)
```

Konfúziós mátrix vizualizálva:
```{r}
conf_matrix<- tibble("prediction"=pred,"target_var" = heart_kesz_test$HeartDisease) %>% 
  table() %>%
  as_tibble() %>% 
  plot_confusion_matrix(prediction_col = "prediction",
                      target_col = "target_var", 
                      counts_col = "n",
                      class_order = c("1","0"))

conf_matrix
```
A false-positive és false-negative becslések e minta esetén mindig kiegyensúlyozottnak mutatkoztak, a szívbetegek és egészségesek közel-azonos jelenléte miatt:
```{r}
heartdiseases <- table(heart_kesz$HeartDisease)
barplot(heartdiseases)
```

Metrikák:
```{r}
cfm <- confusionMatrix(data = factor(pred), reference = factor(heart_kesz_test$HeartDisease), mode = "prec_recall")
cfm$overall[1] #Accuracy
cfm$byClass[5] #Precision
cfm$byClass[6] #Recall
cfm$byClass[7] #F1
```




Ensemble:
```{r}

```


