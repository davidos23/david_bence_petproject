---
title: "Ingatlan piac elemzés"
author: "Szabó Bence Dániel, Sklovskiy David"
date: "11/20/2021"
output: html_document
---

## ________________________________________
## Menetrend:
1. Adat leszedése, tisztítása
2. Három módszer alkalmazása:
  a. ANN
  b. Véletlen erdők
  c. Ensemble módszer
3.Összehasonlítás

Cél: pontosan megbecsülni a szívbetegeket a produkált tünetek alapján.

### Adat kiválasztása
A kiválasztott adat a "heart.csv"


### Szükséges package-k betöltése
```{r}
#Webscrapehez
library(rvest)
#dplyr ( %>% miatt)
library(dplyr)

#ANN
library(neuralnet)
library(nnet)
library(fastDummies)
library(caret)
library(cvms)

#Plot
library(GGally)
```

### Segédfüggvények definiálása
```{r}
norm <- function(x) (x-min(x))/(max(x)-min(x))
classifier <- function(x,cut_off=0.5) {
  if(x < cut_off){
    return(0)
  } else {
    return(1)
  }
}
```


### Adat betöltése:
```{r}
library(readr)
heart <- read_csv("heart.csv")
```


Dummy változók átalakítása oszlopokká, normálás
```{r}
heart_kesz <- dummy_cols(heart, remove_selected_columns = TRUE)
heart_kesz <- sapply(heart_kesz, norm) %>% data.frame()
heart_kesz <- heart_kesz[c("HeartDisease","Age", "RestingBP", "Cholesterol", "FastingBS", "MaxHR", "Oldpeak", "Sex_F", "Sex_M" ,  "ChestPainType_ASY", "ChestPainType_ATA", "ChestPainType_NAP", "ChestPainType_TA", "RestingECG_LVH", "RestingECG_Normal", "RestingECG_ST", "ExerciseAngina_N", "ExerciseAngina_Y", "ST_Slope_Down", "ST_Slope_Flat", "ST_Slope_Up")]
```

___________________________________________________________

###___________________________________________________________
Train-test splites neurális háló:

Adat splittelése:
```{r}
train_index <- createDataPartition(heart_kesz$HeartDisease,p=0.8,list = FALSE)
heart_kesz_train <- heart_kesz[train_index,]
heart_kesz_test <- heart_kesz[-train_index,]
```

Neurális háló:
```{r}
ANN <- neuralnet(HeartDisease~., data = heart_kesz_train,hidden=c(5,3),linear.output = FALSE)
```


Predikcio:
```{r}
selected_cut_off=0.5
#A classifier egy az elején definiált függvény, átalakítja pred-et 0-1-esekből álló vektorrá a selected_cut_off-tól függően
pred <- predict(ANN,heart_kesz_test) %>% round(3)
pred <- sapply(pred,classifier,cut_off=selected_cut_off)
```

Konfúziós mátrix vizualizálva:
```{r}
conf_matrix<- tibble("prediction"=pred,"target_var" = heart_kesz_test$HeartDisease) %>% 
  table() %>%
  as_tibble() %>% 
  plot_confusion_matrix(prediction_col = "prediction",
                      target_col = "target_var", 
                      counts_col = "n",
                      class_order = c("1","0"))

conf_matrix
```
Klasszifikációs mutatók:
```{r}
cfm <- confusionMatrix(data = factor(pred), reference = factor(heart_kesz_test$HeartDisease), mode = "prec_recall")
```
F1 mutató, ezt akarjuk maximalizálni:
```{r}

cfm$overall[1]
cfm$byClass[5]
cfm$byClass[6]
cfm$byClass[7]
```


Átlagos F1 100 train-test-split után:

K db különböző split futtatása, a szükséges mutatókat átlagoljuk:
```{r}
selected_cut_off=0.5 #Ez lesz a választott cut-offunk, de tapasztalatok szerint a becsült bináris adat nagyon ritkán esik túl távol 0-tól vagy 1-től, így a 0.1 vagy 0.9-es cut-off ugyanazt az eredményt nyújtja
ANN_Accuracy = array()
ANN_Precision = array()
ANN_Recall = array()
ANN_F1 = array()

K=50
for (i in 1:K){
  #Splittelés
  train_index <- createDataPartition(heart_kesz$HeartDisease,p=0.3,list = FALSE)
  heart_kesz_train <- heart_kesz[train_index,]
  heart_kesz_test <- heart_kesz[-train_index,]
  
  #Neurális háló tanítása
  ANN_looped <- neuralnet(HeartDisease~., data = heart_kesz_train,hidden=c(5,3),linear.output = FALSE)

  #Becslés
  pred <- predict(ANN_looped,heart_kesz_test) %>% round(3)
  pred <- sapply(pred,classifier,cut_off=selected_cut_off)
  
  #Eredmények feljegyzése
  cfm_looped <- confusionMatrix(data = factor(pred), reference = factor(heart_kesz_test$HeartDisease), mode = "prec_recall")
  
  ANN_Accuracy <- rbind(ANN_Accuracy,cfm_looped$overall[1])
  ANN_Precision <- rbind(ANN_Precision,cfm_looped$byClass[5])
  ANN_Recall <- rbind(ANN_Recall,cfm_looped$byClass[6])
  ANN_F1 <- rbind(ANN_F1,cfm_looped$byClass[7])

  
}
#K soros mérőszám mátrix:
metrics <- cbind(ANN_Accuracy,ANN_Precision, ANN_Recall, ANN_F1)[2:(K+1),]

#A K sor átlaga - egy sorvektor:
average_metrics <- apply(metrics,2,mean)

metrics
average_metrics
```
