```{r}
#Döntési fa a heart failure adatokra
```
```{r}
install.packages("rpart")
install.packages("rpart.plot")
install.packages("randomForest")
install.packages("boot")
library(rpart)
library(rpart.plot)
library(randomForest)
library("boot")
```
0) Adatok jellemzése
Az adatot a https://www.kaggle.com/fedesoriano/heart-failure-prediction címről töltöttük le.

A heart failure adatokat több országból gyűjtötték össze nekünk, az adatstruktúra pedig 12 oszlopból áll. Nevesen
- életkor(numerikus)
- nem (M: male, F: female)
- mellkasi fájdalom típusa (kategórikus)
- nyugalmi vérnyomás (numerikus)
- koleszterin mennyisége (numerikus)
- éhomi vércukorszint (0-1)
- nyugalmi elektrodiogram eredménye (kategórikus)
- maximális szívdobbanás (numerikus)
- Szív-koszorúér fájdalom mozgás hatására (0-1)
- régi csúcsérték (numerical) 
- ST-görbe ?????? (kategórikus)
- Szívbetegség - (1: beteg, 0 egészséges)

Mi arra vállalkoztunk, hogy modellt építsünk a szívbetegség fennállásának eldöntésére.

1) Töltsük be az adatot!
```{r}
file_path <- "/Users/sbeni/suli/Reggelistat/PET-project/heart.csv"
heart_failure <- read.csv(file_path)
```

2) A fa elkészítése
```{r}
decision_tree <- rpart(HeartDisease~., data=heart_failure)
rpart.plot(decision_tree)
#prp(decision_tree)
```
Nézzük meg különböző 'cp (complexity paramter) ' értékek mellett
*a cp érték megmutatj,a hogy mennyire szerteágató a döntési fánk

0-ás cp mellett nagyon elágazó ábrát kapunk
```{r}
tree_0 <- rpart(HeartDisease~., data=heart_failure, cp=0)
rpart.plot(tree_0)
```
0.01-es cp mellett a következő ábrát kapjuk. Itt már szemmel olvashatóbb a fa sűrűsége.
```{r}
tree_001 <- rpart(HeartDisease~., data=heart_failure, cp=0.01)
rpart.plot(tree_001)
```
0.1-es cp mellett pedig gyakorlatilag csak az ST görbe alapján döntött
```{r}
tree_010 <- rpart(HeartDisease~., data=heart_failure, cp=0.1)
rpart.plot(tree_010)
```
Használjuk föl a 'plotcp()' metódust, ami segít megtalálni az ideális cp értéket (tree_0-ra).
```{r}
plotcp(tree_0, minline = TRUE)
```
Leolvasva a 0.0077-es érték a legjobb, de ezt kitudjuk nyerni másképp is.
(ekvivalens : tree_0$cptable)
```{r}
printcp(tree_0)
```

```{r}
cp.select <- function(big.tree) {
  min.x <- which.min(big.tree$cptable[, 4]) #column 4 is xerror
  for(i in 1:nrow(big.tree$cptable)) {
    if(big.tree$cptable[i, 4] < big.tree$cptable[min.x, 4] + big.tree$cptable[min.x, 5]) 
      return(big.tree$cptable[i, 1]) #column 5: xstd, column 1: cp 
  }
}

opt_cp = cp.select(tree_0)
```

Modell sokaság legyártása
```{r}
get_random_indeces <- function(t_n, t_k, df){
  "
  t_n : number of desired rows for test data
  t_k : number of maximum unique rows from df
  note that t_k < = t_n
  
  this function gives random indeces for the testing data. This means if you use it, the testing data likely to have
  same indeces.
  "
  if (t_k <= t_n){
    rand_list = sample(1:t_k)
    remain_list = sample(1:(t_n-t_k))
    return(append(rand_list,remain_list))
  }else{
    return("Not well given inputs. Please check the function how to use it!")
  }
}
```

```{r}
kakken = c(1,2,3,4,4,5,6)
filtered = heart_failure[kakken,]
```

 
 